<img width="1036" height="582" alt="image" src="https://github.com/user-attachments/assets/88e72aff-a56f-4b56-82b2-98556dd785a0" />

<img width="862" height="472" alt="image" src="https://github.com/user-attachments/assets/6208bc1a-dc08-4ba7-8bbd-aaaded3c9e16" />

<img width="1022" height="824" alt="Screenshot 2025-07-24 133006" src="https://github.com/user-attachments/assets/5045fe96-d671-4f79-a0d2-fd1643850863" />


# I2C device Driver

<img width="1916" height="552" alt="image" src="https://github.com/user-attachments/assets/126a77be-7f6f-40ed-a382-55c707f150ed" />


### Drivers
This is the driver that we are writing for the client.

Usually, Driver and Client are more closely integrated than Algorithm and Adapter.

**So, you will need a driver for your I2C bus, and drivers for your I2C devices (usually one driver for each device).**

### How I2C bus driver works
- I2C client driver initiates transfer using a function like i2c_transfer, i2c_master_send etc.
- It comes to the master_xfer function in the bus driver (drivers/i2c/busses/*).
- The bus driver splits the entire transaction into START, STOP, ADDRESS, READ with ACK, READ with NACK, etc. These conditions have to be created on the real i2c bus. The bus driver writes to the I2C hardware adaptor to generate these conditions on the I2C bus one by one, sleeping on a wait queue in between (basically giving the CPU to some other task to do some useful job rather than polling until hardware finishes).
- Once the hardware has finished a transaction on the bus (for eg a START condition), an interrupt will be generated and the ISR will wake up the sleeping master_xfer.
- Once master_xfer wakes up, he will go and advise the hardware adaptor to send the second condition (for eg ADDRESS of the chip).
- This continues till the whole transaction is over and return back to the client driver.

