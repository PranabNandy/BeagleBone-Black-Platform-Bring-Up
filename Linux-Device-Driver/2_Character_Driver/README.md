<h1> Character Driver Basic </h1>

- Character driver accesses data from the device sequentially. i.e., byte by byte (like a stream of characters) not as a chunk of data.
- Sophisticated buffering strategies are usually not involved in char drivers. Because when you write 1 byte, it directly goes to the device without any intermediate buffering, delayed write back, dirty buffer management.
- Char devices: sensors, RTC, keyboard, serial port, parallel port,...etc.

## 1. Code exercise
- Write a character driver to deal with a pseudo character device.
- The pseudo-device is a memory buffer of some size (in case 512 byte).
- The driver what you write must support reading/writing/seeking to this device .
- Test the driver functionality by running user-level command such as echo, dd, cat and by writing user lever programs.
- Write application running on user-level for test the driver functionality.

## 2. Connection establishment between device file access and the driver

### Step 1: Create device number
- The device number is a combination of major and minor numbers.
- In Linux kernel, `dev_t` *(typedef of u32)* type is used to represent the device number.
- Out of **32 bits**, **12 bits** to store **major number** and remaining **20 bits** to store **minor number**
- You can use the below macros to extract major and minor parts of `dev_t` type variable:
```text
#include <linux/kdev_t.h>

dev_t device_number;
int minor = MINOR(device_number);
int major = MAJOR(device_number);
```
- If you have major and minor numbers, use the below macro to turn them into `dev_t` type device number:
```text
MKDEV(int major, int minor);
```
**- Dynamically register a range of char device numbers**
```text
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)
```
+ **dev_t \*dev**: Output parameter for first assigned number 
+ **unsigned baseminor**: first of the requested range of minor numbers
+ **unsigned count**: number of minor numbers required
+ **const char \*name**: name of the associated device or driver

**Example:**
```text
#include <linux/fs.h>

dev_t device_number;
alloc_chrdev_region(&device_number, 0, 1, "pcd_devices");
```

### Step 2: Create device files
**- Initialize a cdev_init structure**
```text
void cdev_init (struct cdev *cdev, const struct file_operations *fops)
```
+ **struct cdev \*cdev**: the structure to initialize
+ **const struct file_operations \*fops**: the file operations for this device (open, read, write, lseek, mmap, flush,...)
+ `THIS_MODULE` is a macro which resolves in to "pointer to a struct module variable which corresponds to our current module"

**- cdev_add - add a char device to the system**
```text
int cdev_add (struct cdev *p, dev_t dev, unsigned count)
```
+ **struct cdev \*p**: the `cdev` structure for the device
+ **dev_t dev**: the first device number for which this device is responsible
+ **unsigned count**: the number of consecutive minor numbers corresponding to this device

**Example:**
```text
#include <linux/cdev.h>

struct cdev pcd_cdev;
struct file_operations pcd_fops = {
    .open       = pcd_open,
    .write      = pcd_write,
    .read       = pcd_read,
    .release    = pcd_release,
    .llseek     = pcd_lseek,
    .owner      = THIS_MODULE
};

cdev_init(&pcd_cdev, &pcd_fops);
cdev_add(&pcd_cdev, device_number, 1);
```

### Step 3: Make a char device registration with the VFS
- In Linux, you can create a device file dynamically (on demand), i.e you need not manually create the device files under `/dev` directory to access your hardware.
- User-level program such as `udevd` can populate `/dev` directory with device files dynamically.
- `udev` program listens to the `uevents` generated by hot plug events or kernel modules. When `udev` receives the `uevents`, it scans the subdirectories of `/sys/class` looking for the **"dev"** files to create device files.
- For each such **'dev'** file, which represents a combination of major and minor number for a device, the `udev` program creates a corresponding device file in `/dev` directory.
<p align="center"> <img width="850" src="https://user-images.githubusercontent.com/32474027/94242763-8068b100-ff51-11ea-9faa-69cfdfd77c73.png" /> </p>

**- Create and register a class with sysfs**
```text
struct class *class_create(struct module *owner, const char *name)
```
+ **struct module \*owner**: pointer to the module that is to “own” this struct class
+ **const char \*name**: pointer to a string for the name of this class

**- Populates the sysfs class you created in previous step with device numbers and device names**
```text
struct device *device_create (struct class *class, struct device *parent, dev_t devt, const char *fmt, ...)
```
+ **struct class \*class**: pointer to the struct class that this device should be registered to
+ **struct device \*parent**: pointer to the parent struct device of this new device, if any
+ **dev_t devt**: the dev_t for the char device to be added
+ **const char \*fmt**: string for the device's name

**Example:**
```text
#include <linux/device.h>

struct class *class_pcd;
struct device *device_pcd;

class_pcd = class_create(THIS_MODULE, "pcd_class");
device_pcd = device_create(class_pcd, NULL, device_number, NULL, "pcd");
```

### Step 4: Implement the driver’s file operation methods for open, read, write, lseek.
- In this character driver we will give support to handle the below user level system call (open/close/read/write/llseek)

- Open: 
    + Initialize the device or make device respond for `read/write` access
    + Detect device initialization errors
    + Check open permission **(O_RDONLY, O_WRONLY, O_RDWR)**
    + Identify the device being opened using minor number
    + Prepare device private data structure if required
    + Update `f_pos` if required
    + Open method is optional. If not provided, open will always succeed and driver is not notified.

```text
int (*open) (struct inode *inode, struct file *filp)
```

- Close:
    + In release method the driver can do reverse operation of what open had done.
        + E.g. if open method brings the device out of low power mode, then release method may send the device back to the low power mode.
        + Basically you should leave the device in its default state, the state which was before the open call.
        + Free any data structures allocated by the open method
    + Return 0 on success. Negative error code if any errors
    + For example you try to de-initialize the device and the device doesn’t respond
```text
int (*release) (struct inode *inode, struct file *filp)
```

- Read:
    + Read `count` bytes from a device starting at position `f_pos`
    + Update the `f_pos` by adding the number bytes successfully read
    + Return number of bytes successfully read
    + Return 0 if there is no bytes to read (EOF)
    + Return appropriate error code (-ve value) if any error
    + A return value less than `count` does not mean that an error has occurred
```text
ssize_t (*read) (struct file *filp, char __user *buff, size_t count, loff_t *f_pos)
```

- Write:
    + Write `count` bytes into the device starting at position `f_pos`
    + Update the `f_pos` by adding the number bytes successfully written
    + Return number of bytes successfully written
    + Return appropriate error code (-ve value) if any error
```text
ssize_t (*write) (struct file *filp, const char __user *buff, size_t count, loff_t *f_pos)
```

- Llseek:
    + In the llseek method, driver should update the file pointer by using `offset` and `whence` information
    + The llseek handler should return, newly updated file position or error
```text
loff_t (*llseek) (struct file *filp, loff_t offset, int whence)
```

+ **struct inode \*inode**: pointer of inode associated with filename
+ **struct file \*filp**: pointer of file object
+ **const char __user \*buff**: pointer of user buffer
+ **size_t count**: count given by user
+ **loff_t \*f_pos**: pointer of current file position from which the write has to begin
+ **loff_t offset**: offset value
+ **int whence**: point from which offset is to be interpreted (SEEK_SET, SEEK_CUR, SEEK_END)

#### Summary
<p align="center"> <img width="750" src="https://user-images.githubusercontent.com/32474027/94337200-c130fa80-0023-11eb-8b6d-e842ba12116f.png"> </p>

- When device file gets created
1. Create device file using `udev`
2. Inode object gets created in memory and inode's `i_rdev` field is initialized with device number
3. Inode object's `i_fop` field is set to dummy default file operations (def_chr_fops)

- When user process executes open system call
1. User invokes open system call on the device file
2. File object gets created
3. Inode's `i_fop` gets copied to file object's `f_op` (dummy default file operations of char device file)
4. Open function of dummy default file operations gets called (chrdev_open)
5. Inode object's `i_cdev` field is initialized with `cdev` which you added during `cdev_add` (lookup happens using inode-> i_rdev field)
6. `inode->cdev->fops` (this is a real file operations of your driver) gets copied to `file->f_op`
7. `file->f_op->open` method gets called (read open method of your driver)


## 3. Other kernel APIs & Macros

### 3.1. Character driver clean-up function
- Remove a device that was created with `device_create()`
```text
void device_destroy(struct class *class, dev_t devt)
```
- Destroys a struct class structure
```text
void class_destroy(struct class *cls)
```
- Remove `cdev` registration from the kernel VFS
```text
void cdev_del(struct cdev *p)
```
- Unregister a range of device numbers
```text
void unregister_chrdev_region(dev_t from, unsigned count)
```
+ **struct class \*class**: pointer to the struct class that this device was registered with
+ **dev_t devt**: `dev_t` of the device that was previously registered
+ **struct class \*cls**: pointer to the struct class that is to be destroyed
+ **struct cdev \*p**: `cdev` structure to be removed
+ **dev_t from**: the first in the range of numbers to unregister
+ **unsigned count**: number of device numbers to unregister

### 3.2. Error handling of pointers during kernel function return
- You can use some kernel macros to deal with return of error pointers by kernel functions.
- The below macros help to understand what made kernel function to fail:
    + IS_ERR()
    + PTR_ERR()
    + ERR_PTR()
- These macros can be found in include `include/linux/err.h`
- Error codes and descriptions (Ex: ENOMEM/EPERM/ENFILE/...): `include/uapi/asm-generic/errno-base.h`

### 3.3. Data copying between Kernel space and user space
- Copying data between user space and kernel space
- Check whether the user space pointer is valid or not
- If the pointer is invalid, no copy is performed
- If an invalid address is encountered during the copy, only part of the data is copied. In both cases, the return value is the **amount of memory still to be copied**
```text
unsigned long copy_to_user(void __user *to, const void *from, unsigned long n)
```
- **void __user \*to**: Destination address, in user space
- **const void \*from**: Source address, in kernel space
- **unsigned long n**: Number of bytes to copy

```text
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)
```
- **void \*to**: Destination address, in kernel space
- **const void __user \*from**: Source address, in user space

## 4. Testing
- Step 1: Generate `*.ko` and test pcd object
```shell
root@nekobot:~/02_Character_Driver# make
```
- Step 2: Load kernel module
```shell
root@nekobot:~/02_Character_Driver# insmod pcd.ko
```
- Step 3.1: Using `cat` and `echo` command for read and write
```shell
$ root@nekobot:~/02_Character_Driver# echo "Someone like you" > /dev/pcd
$ root@nekobot:~/02_Character_Driver# cat /dev/pcd
```
- Step 3.2: Using test pcd
```shell
$ root@nekobot:~/02_Character_Driver# ./pcdtest
    Starting device test code example...
    Type in a short string to send to the kernel module:
    You are my apple     
    Press ENTER to read back from the device...

    The received message is: You are my apple

    End of the program
```
- Step 4: Unload module
```shell
root@nekobot:~/02_Character_Driver# rmmod pcd.ko
```
**Note:** You can check kernel log by command `dmesg | tail`
